1. 从 Linux 0.11 现在的机制看，它的系统调用最多能传递几个参数？你能想出办法来扩大这个限制吗？
答：
（1）从 linux-0.11/include/unistd.h 文件中的 _syscall3 可以知道，目前它的系统调用最多能传递 3 个参数。
（2）扩大限制的方法一：多加几个 _syscall ，分别可以传递的参数就可以一直扩大。
（3）扩大限制的方法二：将需要传递的多个参数保存在特定结构的区间中，并将该用户态地址空间的这个区间的首地址作为一个参数传递给系统调用。最后通过寄存器间接寻址方式便可以访问所有参数。当然，这么做的话，参数合法性验证尤其必要。实际上，linux2.6内核废除了_syscall宏，而使用syscall函数，其接受一个可变参数，原理类似，参考《深入理解Linux内核（第三版）》 P409。


2. 用文字简要描述向 Linux 0.11 添加一个系统调用 foo() 的步骤。
答：
（1）更改 /linux-0.11/include/unistd.h 文件
添加系统调用的编号
#define __NR_foo num
num 为系统调用号

（2）更改 /linux-0.11/kernel/system_call.s 文件
更改内核函数中系统调用的总数，因为中断调用的时候会检查系统调用编号是否在合法范围内
nr_system_calls = num
num 为在原值上加 1，即系统调用总数加 1

（3）更改 /linux-0.11/include/linux/sys.h 文件
仿照此文件中前面各个系统调用的写法，引用实验要求增加的系统调用（引用外部的函数）
    extern int sys_foo();
在中断处理函数所调用的函数表中增加两个函数引用在
    “函数指针数组” 中添加 sys_foo，函数在数组中的位置必须和 __NR_xxxxxx 的值对应上。

（4）添加 /linux-0.11/kernel/foo.c 文件
创建一个文件 foo.c，在里面实现我们要添加的系统调用 sys_foo()

（5）更改 /linux-0.11/kernel/makefile 文件
添加 OBJS 变量后面的依赖文件 foo.o
添加依赖 foo.s 和 foo.o 的生成规则

（6）用户模式下
添加的测试应用程序源代码中
#define __LIBRARY__
#include <unistd.h>
_syscallN 宏展开系统调用，这样就相当于给用户程序提供了系统调用的接口
