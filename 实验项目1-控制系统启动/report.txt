有时，继承传统意味着别手蹩脚。x86 计算机为了向下兼容，导致启动过程比较复杂。请找出 x86 计算机启动过程中，
被硬件强制，软件必须遵守的两个“多此一举”的步骤（多找几个也无妨），说说它们为什么多此一举，并设计更简洁的替代方案。

答：
（1） bootsect.s 从硬盘中先被加载到内存物理地址 0x7c000 处，后又挪动到了物理地址 0x90000 处
    原因：
    由于 BIOS 的硬件限制，引导扇区（bootsect.s） 在计算机启动时，从硬盘中先被加载到内存物理地址 0x7c000 处，后面又为了给 system 模块腾出空间，引导程序又将自己移动到内存靠后的位置，也就是 0x90000 处。

    解决方案：
    在保证可靠性的前提下尽量扩大实地址模式下 BIOS 可访问的内存的范围，这样就可以直接将引导扇区加载到 0x90000 或者更高的内存地址处，就避免了二次的转移。


（2） system 模块从硬盘中先被加载到内存物理地址 0x10000 处，后又挪动到了物理地址 0x00000 处
    原因：
    在计算机启动的时候，会执行 BIOS 中的初始化程序，初始化程序主要的功能是在内存物理地址 0 处建立 BIOS 所支持的中断向量，即将 BIOS 提供的中断例程的入口地址登记在中断向量表中。
    linux 0.11 的 system 模块被 bootsect.s 程序加载到 0x10000 处，等后续 setup.s 程序执行的时候，又会将 system 模块移动到 0x00000 处，目的是避免 system 模块直接写到 0x00000 处覆盖了中断向量表。（因为在移动 system 模块之前，setup 代码还需要利用 ROM BIOS 中的中断向量表来获取机器的一些参数）

    解决方案：
    初始化程序时，将 ROM BIOS 的中断向量表放到实模式下能寻址内存的其他地方，这样操作系统的 system 模块就可以直接存放到 0x00000 处，避免二次的转移。
