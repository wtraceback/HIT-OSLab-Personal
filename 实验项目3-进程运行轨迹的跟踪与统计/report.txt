完成实验后，在实验报告中回答如下问题：

1. 结合自己的体会，谈谈从程序设计者的角度看，单进程编程和多进程编程最大的区别是什么？
    1. 执行方式：
    单进程编程所写的程序是顺序执行的，彼此之间有严格的执行逻辑；在没有其他程序的干扰下，数据是同步的。
    多进程编程所写的程序是同时触发，交替执行的，也就是并发执行，如某一个进程正在进行 I/O 操作而不占用 CPU 时，可以让 CPU 去执行另外一个进程，这需要采取某种调度算法。虽然共享文件等，但是由于多个进程之间执行顺序无法得知，故而要考虑进程之间的关系和影响，尤其是数据异步，程序员要做好进程之间同步，通信，互斥等。

    2. 数据是否同步：
    单进程的数据是同步的，因为单进程只有一个进程，在进程中改变数据的话，是会影响这个进程的；
    多进程的数据是异步的，因为子进程数据是父进程数据在内存另一个位置的拷贝，因此改变其中一个进程的数据，是不会影响到另一个进程的。

    3. CPU 利用率：
    单进程编程的 CPU 利用率低，因为单进程在等待 I/O 时，CPU 是空闲的；
    多进程编程的 CPU 利用率高，因为当某一进程等待 I/O 时，CPU 会去执行另一个进程，因此 CPU 的利用率高。

    4. 总而言之，多进程编程比单进程编程复杂得多，但是多进程编程用途要更广泛。

2. 你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后，log 文件的统计结果（不包括 Graphic）都是什么样？结合你的修改分析一下为什么会这样变化，或者为什么没变化？
    在 linux-0.11 源码 /include/linux/sched.h 中修改 #define INIT_TASK 宏定义中 priority 的数值
    原始时间片为15，修改了三次时间片，分别为 5、25、50，结果如下：

    时间片为 5
    (Unit: tick)
    Process     Turnaround      Waiting     CPU Burst       I/O Burst
        7           2122            23          0               2099
        8           3706            1621        200             1885
        9           3732            3020        400             312
        10          3737            3287        450             0
        11          3729            3279        450             0
        12          3684            3239        445             0
        13          3678            3233        445             0
        14          3673            3228        445             0
        15          3667            3222        445             0
        16          3661            3216        445             0
    Average:        3538.90         2736.80
    Throughout: 0.27/s


    时间片为 15
    (Unit: tick)
    Process         Turnaround          Waiting         CPU Burst       I/O Burst
        7               2247                142             0               2105
        8               2944                1686            200             1057
        9               2973                2628            345             0
        10              2957                2612            345             0
        11              2942                2597            345             0
        12              2926                2581            345             0
        13              2908                2563            345             0
        14              2893                2548            345             0
        15              2877                2532            345             0
        16              2861                2516            345             0
    Average:            2852.80             2240.50
    Throughout: 0.34/s


    时间片为 25
    (Unit: tick)
    Process     Turnaround      Waiting     CPU Burst       I/O Burst
        7           2732            232         0               2500
        8           4188            1807        200             2181
        9           4189            3187        400             602
        10          4288            3763        525             0
        11          4262            3737        525             0
        12          4237            3712        525             0
        13          4211            3686        525             0
        14          4182            3657        525             0
        15          4157            3632        525             0
        16          4131            3606        525             0
    Average:        4057.70         3101.90
    Throughout: 0.23/s


    时间片为 50
    (Unit: tick)
    Process     Turnaround      Waiting     CPU Burst       I/O Burst
        7           3458            458         0               3000
        8           4812            2008        200             2604
        9           5313            3358        400             1555
        10          5413            4513        600             300
        11          5412            4712        700             0
        12          5361            4661        700             0
        13          5311            4611        700             0
        14          5258            4558        700             0
        15          5207            4507        700             0
        16          5157            4457        700             0
    Average:        5070.20         3784.30
    Throughout：0.18/s


    1. 当时间片非常小的时候，平均周转时间和平均等待时间应该是非常大的，因为进程切换地太频繁，浪费大量的时间在进程切换上。
    2. 当时间片适宜的时候，平均周转时间和平均等待时间是最低的，因为既不会浪费大量时间在进程切换上，又不会让只需占用一小会 CPU 的进程等待太多的时间（也就是说对于只占用 CPU 很短时间的进程而言，它不会等待太多的时间）。
    3. 当时间片足够大的时候，就变成了先进先出的调度算法，虽然不会浪费时间在进程切换上，但是又可能引起对短的交互请求的响应变差，平均周转时间和平均等待时间可能又会变大。
    4. 故而需要设置合理的时间片，既不能过大，也不能过小。
