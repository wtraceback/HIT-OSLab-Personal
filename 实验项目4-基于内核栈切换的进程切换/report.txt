1. 问题 1
针对下面的代码片段：
movl tss, %ecx
addl $4096, %ebx
movl %ebx, ESP0(%ecx)

回答问题：
（1）为什么要加 4096；
答：4096 字节等于 4KB。由于 Linux 0.11 进程的内核栈和该进程的 PCB 在同一页内存上（一块 4KB 大小的内存），其中 PCB 位于这页内存的低地址，栈位于这页内存的高地址。ebx 指向下一个进程的 PCB，偏移 4KB 之后，便能指向该进程的内核栈地址。
（2）为什么没有设置 tss 中的 ss0。
答：因为 tss.ss0 默认设置为 0x10，已经处于内核态中，而且现在所有的进程都共用一个 tss，因此不需要每次切换都去设置。




2. 问题 2
针对代码片段：
*(--krnstack) = ebp;
*(--krnstack) = ecx;
*(--krnstack) = ebx;
*(--krnstack) = 0;

回答问题：
（1）子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？
答：eax = 0，目的是为了将父子进程区分开，改写的 copy_process 函数中 *(--krnstack) = 0; ，该代码经过出栈操作后，将 0 赋值给 eax 寄存器，最后经过 iret 指令后，在用户态就能得到调用 fork() 函数的返回值，等于 0 就代表是子进程。（即可以使用这样的代码 if (!fork()) {...}）
（2）这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？
答：ebx 和 ecx 来自 copy_process() 函数的参数，这些参数来自调用 copy_proces() 的进程的内核栈中，就是父进程的内核栈中，所以对于 fork() 函数而言，子进程是父进程内核栈数据的拷贝，就是要让父子进程共用同一个代码、数据和堆栈。这样可以保证切换到子进程用户态运行时，子进程和父进程处于同样的环境。
（3）这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？
答：ebp 来自于父进程，保存的是父进程用户栈基地址指针。即在 fork 刚刚执行完 copy_process 的时候，它的用户栈是父进程的用户栈，而非自己的用户栈。当子进程进行其他操作时，造成需要的栈将要与父进程不同了，才会创建自己的用户栈。这么做的好处时当一些子进程什么都不做，系统不用分配额外的空间。这就是 Copy On Write。




3. 问题 3
为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？
答：为了重新去查 GDT 表，重新取一下段寄存器 fs 的值，是必须要加的，也必须要出现在切换完 LDT 之后，这是因为通过 fs 访问进程的用户态内存，LDT 切换完成就意味着切换了分配给进程的用户态内存地址空间，所以前一个 fs 指向的是上一个进程的用户态内存，而现在需要执行下一个进程的用户态内存，所以就需要重取 fs。
如果出现在 LDT 之前访问的就还是上一个进程的用户态内存。